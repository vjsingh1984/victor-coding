# Copyright 2025 Vijaykumar Singh <singhvjd@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Refactoring Workflows for Coding Vertical
# ==========================================
# Multi-step workflows for safe code refactoring with verification.
# Supports: rename, extract, restructure, and optimization refactorings.

workflows:
  # ===========================================================================
  # Full Refactoring Workflow
  # ===========================================================================
  refactor:
    description: "Systematic code refactoring with safety checks"

    metadata:
      version: "1.0"
      author: "victor"
      vertical: coding
      category: refactoring
      complexity: medium

    nodes:
      # =====================================================================
      # Stage 1: Analyze Current State
      # =====================================================================
      - id: analyze_code
        type: agent
        name: "Analyze Code Structure"
        role: researcher
        goal: |
          Analyze the code to understand what needs refactoring:
          1. Identify the target code (functions, classes, modules)
          2. Understand current structure and dependencies
          3. Find all usages and references
          4. Identify potential risks
          5. Note existing tests that cover this code
        tool_budget: 30
        tools: [read, grep, code_search, refs, symbol]
        llm_config:
          temperature: 0.2
        output: code_analysis
        next: [run_baseline_tests]

      # =====================================================================
      # Stage 2: Baseline Tests
      # =====================================================================
      - id: run_baseline_tests
        type: compute
        name: "Run Baseline Tests"
        handler: test_runner
        inputs:
          test_command: $ctx.test_command
          timeout: 180
        output: baseline_tests
        constraints:
          llm_allowed: false
          timeout: 180
        next: [check_baseline]

      - id: check_baseline
        type: condition
        name: "Check Baseline Tests"
        condition: "tests_passing"
        branches:
          "passing": plan_refactor
          "failing": warn_failing_tests
          "no_tests": plan_refactor

      - id: warn_failing_tests
        type: hitl
        name: "Warn About Failing Tests"
        hitl_type: approval
        prompt: |
          ## Warning: Tests Already Failing

          Some tests are already failing before refactoring:
          {baseline_tests}

          Proceeding with refactoring may make it harder to verify changes.
          Do you want to continue anyway?
        context_keys:
          - baseline_tests
        timeout: 300
        fallback: continue
        next: [plan_refactor]

      # =====================================================================
      # Stage 3: Plan Refactoring
      # =====================================================================
      - id: plan_refactor
        type: agent
        name: "Plan Refactoring"
        role: planner
        goal: |
          Create a detailed refactoring plan:
          1. List all changes needed in order
          2. Identify files that will be modified
          3. Note any API changes
          4. Plan for backward compatibility if needed
          5. Identify tests that may need updates
        tool_budget: 15
        tools: [read, grep]
        llm_config:
          temperature: 0.3
        input_mapping:
          analysis: code_analysis
        output: refactor_plan
        next: [assess_complexity]

      - id: assess_complexity
        type: condition
        name: "Assess Complexity"
        condition: "complexity_assessment"
        branches:
          "simple": quick_refactor
          "moderate": standard_refactor
          "complex": staged_refactor
          "major": approve_major

      # =====================================================================
      # Stage 4a: Quick Refactor (simple changes)
      # =====================================================================
      - id: quick_refactor
        type: agent
        name: "Quick Refactor"
        role: executor
        goal: |
          Apply the simple refactoring:
          1. Make the planned changes
          2. Keep changes minimal and focused
          3. Preserve existing behavior
        tool_budget: 20
        tools: [read, edit, write]
        llm_config:
          temperature: 0.1
        input_mapping:
          plan: refactor_plan
        output: refactor_result
        next: [verify_changes]

      # =====================================================================
      # Stage 4b: Standard Refactor (moderate changes)
      # =====================================================================
      - id: standard_refactor
        type: agent
        name: "Standard Refactor"
        role: executor
        goal: |
          Apply the refactoring step by step:
          1. Make changes in order from plan
          2. Update imports and references
          3. Fix any type errors introduced
          4. Ensure code compiles/parses
        tool_budget: 35
        tools: [read, edit, write, grep]
        llm_config:
          temperature: 0.1
        input_mapping:
          plan: refactor_plan
          analysis: code_analysis
        output: refactor_result
        next: [verify_changes]

      # =====================================================================
      # Stage 4c: Staged Refactor (complex changes)
      # =====================================================================
      - id: staged_refactor
        type: agent
        name: "Staged Refactor"
        role: executor
        goal: |
          Apply complex refactoring in stages:
          1. First stage: Structural changes
          2. Second stage: Update references
          3. Third stage: Clean up and optimize
          Verify compilation after each stage.
        tool_budget: 50
        tools: [read, edit, write, grep, shell]
        llm_config:
          temperature: 0.1
        input_mapping:
          plan: refactor_plan
          analysis: code_analysis
        output: refactor_result
        next: [verify_changes]

      # =====================================================================
      # Stage 4d: Major Refactor (needs approval)
      # =====================================================================
      - id: approve_major
        type: hitl
        name: "Approve Major Refactoring"
        hitl_type: approval
        prompt: |
          ## Major Refactoring Required

          **Analysis:**
          {code_analysis}

          **Proposed Plan:**
          {refactor_plan}

          This is a major refactoring that will touch many files.
          Do you approve this plan?
        context_keys:
          - code_analysis
          - refactor_plan
        timeout: 600
        fallback: abort
        next: [staged_refactor]

      # =====================================================================
      # Stage 5: Verify Changes
      # =====================================================================
      - id: verify_changes
        type: compute
        name: "Run Tests After Refactor"
        handler: test_runner
        inputs:
          test_command: $ctx.test_command
          timeout: 180
        output: test_results
        constraints:
          llm_allowed: false
          timeout: 180
        next: [check_tests]

      - id: check_tests
        type: condition
        name: "Check Test Results"
        condition: "tests_passing"
        branches:
          "passing": check_quality
          "failing": fix_failures
          "no_tests": check_quality

      - id: fix_failures
        type: agent
        name: "Fix Test Failures"
        role: executor
        goal: |
          Fix the test failures caused by refactoring:
          1. Analyze which tests are failing
          2. Determine if tests need updating or code needs fixing
          3. Apply necessary fixes
        tool_budget: 25
        tools: [read, edit, grep]
        llm_config:
          temperature: 0.2
        input_mapping:
          test_results: test_results
          refactor_result: refactor_result
        output: fix_result
        next: [should_retry]

      - id: should_retry
        type: condition
        name: "Should Retry"
        condition: "should_continue_fixing"
        branches:
          "continue_fixing": verify_changes
          "submit_best_effort": check_quality
          "escalate": escalate_human

      - id: escalate_human
        type: hitl
        name: "Escalate to Human"
        hitl_type: input
        prompt: |
          ## Refactoring Issues

          The refactoring resulted in test failures that could not be automatically fixed.

          **Changes Made:**
          {refactor_result}

          **Test Failures:**
          {test_results}

          Please provide guidance on how to proceed.
        context_keys:
          - refactor_result
          - test_results
        timeout: 600
        fallback: continue
        next: [fix_failures]

      # =====================================================================
      # Stage 6: Quality Check
      # =====================================================================
      - id: check_quality
        type: compute
        name: "Check Code Quality"
        handler: code_validation
        inputs:
          check_lint: true
          check_types: true
        output: quality_results
        constraints:
          llm_allowed: false
          timeout: 120
        next: [assess_quality]

      - id: assess_quality
        type: condition
        name: "Assess Quality"
        condition: "code_quality_check"
        branches:
          "excellent": finalize
          "good": finalize
          "acceptable": improve_quality
          "needs_improvement": improve_quality

      - id: improve_quality
        type: agent
        name: "Improve Quality"
        role: executor
        goal: |
          Address quality issues from refactoring:
          1. Fix linting errors
          2. Resolve type errors
          3. Improve formatting
        tool_budget: 15
        tools: [read, edit, shell]
        llm_config:
          temperature: 0.1
        output: quality_fixes
        next: [finalize]

      # =====================================================================
      # Stage 7: Finalize
      # =====================================================================
      - id: finalize
        type: transform
        name: "Finalize Refactoring"
        transform: |
          status = "completed"
          success = True
          files_changed = ctx.get("refactor_result", {}).get("files", [])


  # ===========================================================================
  # Rename Refactoring Workflow
  # ===========================================================================
  rename:
    description: "Safe symbol renaming with reference updates"

    metadata:
      version: "1.0"
      vertical: coding
      category: refactoring
      complexity: low

    nodes:
      - id: find_symbol
        type: agent
        name: "Find Symbol"
        role: researcher
        goal: |
          Find the symbol to rename and all its references:
          1. Locate the symbol definition
          2. Find all usages across the codebase
          3. Identify import statements
          4. Note any dynamic references (strings, comments)
        tool_budget: 20
        tools: [read, grep, code_search, refs, symbol]
        llm_config:
          temperature: 0.2
        output: symbol_info
        next: [apply_rename]

      - id: apply_rename
        type: agent
        name: "Apply Rename"
        role: executor
        goal: |
          Rename the symbol everywhere:
          1. Rename the definition
          2. Update all references
          3. Update imports
          4. Update comments and docstrings
        tool_budget: 30
        tools: [read, edit]
        llm_config:
          temperature: 0.1
        input_mapping:
          symbol: symbol_info
          new_name: $ctx.new_name
        output: rename_result
        next: [verify_rename]

      - id: verify_rename
        type: compute
        name: "Verify Rename"
        handler: test_runner
        inputs:
          test_command: $ctx.test_command
          timeout: 120
        output: test_results
        constraints:
          llm_allowed: false
          timeout: 120
        next: [check_rename]

      - id: check_rename
        type: condition
        name: "Check Rename Result"
        condition: "tests_passing"
        branches:
          "passing": complete
          "failing": fix_rename
          "no_tests": complete

      - id: fix_rename
        type: agent
        name: "Fix Rename Issues"
        role: executor
        goal: |
          Fix any issues from the rename:
          1. Find missed references
          2. Fix import errors
          3. Update any remaining occurrences
        tool_budget: 20
        tools: [read, edit, grep]
        llm_config:
          temperature: 0.2
        output: fix_result
        next: [verify_rename]

      - id: complete
        type: transform
        name: "Complete"
        transform: |
          status = "completed"
          success = True


  # ===========================================================================
  # Extract Function/Method Workflow
  # ===========================================================================
  extract:
    description: "Extract code into new function or method"

    metadata:
      version: "1.0"
      vertical: coding
      category: refactoring
      complexity: medium

    nodes:
      - id: analyze_extraction
        type: agent
        name: "Analyze Extraction"
        role: researcher
        goal: |
          Analyze the code to extract:
          1. Identify the code block to extract
          2. Determine inputs (parameters needed)
          3. Determine outputs (return values)
          4. Check for side effects
          5. Identify the best location for new function
        tool_budget: 20
        tools: [read, grep, symbol]
        llm_config:
          temperature: 0.2
        output: extraction_analysis
        next: [create_function]

      - id: create_function
        type: agent
        name: "Create New Function"
        role: executor
        goal: |
          Create the new function and update call sites:
          1. Create the new function with proper signature
          2. Add appropriate docstring
          3. Replace original code with function call
          4. Handle return values properly
        tool_budget: 25
        tools: [read, edit, write]
        llm_config:
          temperature: 0.1
        input_mapping:
          analysis: extraction_analysis
          function_name: $ctx.function_name
        output: extraction_result
        next: [verify_extraction]

      - id: verify_extraction
        type: compute
        name: "Verify Extraction"
        handler: test_runner
        inputs:
          test_command: $ctx.test_command
          timeout: 120
        output: test_results
        constraints:
          llm_allowed: false
          timeout: 120
        next: [check_extraction]

      - id: check_extraction
        type: condition
        name: "Check Extraction"
        condition: "tests_passing"
        branches:
          "passing": complete
          "failing": fix_extraction
          "no_tests": complete

      - id: fix_extraction
        type: agent
        name: "Fix Extraction Issues"
        role: executor
        goal: |
          Fix issues with the extraction:
          1. Check parameter passing
          2. Verify return value handling
          3. Fix scope issues
        tool_budget: 20
        tools: [read, edit]
        llm_config:
          temperature: 0.2
        output: fix_result
        next: [verify_extraction]

      - id: complete
        type: transform
        name: "Complete"
        transform: |
          status = "completed"
          success = True


  # ===========================================================================
  # Code Optimization Workflow
  # ===========================================================================
  optimize:
    description: "Performance optimization with benchmarking"

    metadata:
      version: "1.0"
      vertical: coding
      category: refactoring
      complexity: high

    nodes:
      - id: profile_code
        type: agent
        name: "Profile Code"
        role: researcher
        goal: |
          Analyze the code for optimization opportunities:
          1. Identify performance bottlenecks
          2. Find inefficient algorithms or data structures
          3. Locate redundant computations
          4. Check for memory inefficiencies
        tool_budget: 25
        tools: [read, grep, shell]
        llm_config:
          temperature: 0.2
        output: profile_results
        next: [plan_optimization]

      - id: plan_optimization
        type: agent
        name: "Plan Optimization"
        role: planner
        goal: |
          Create optimization plan:
          1. Prioritize optimizations by impact
          2. Consider trade-offs (readability vs speed)
          3. Plan benchmarking approach
          4. Identify risks
        tool_budget: 15
        tools: [read]
        llm_config:
          temperature: 0.3
        input_mapping:
          profile: profile_results
        output: optimization_plan
        next: [apply_optimization]

      - id: apply_optimization
        type: agent
        name: "Apply Optimizations"
        role: executor
        goal: |
          Implement the optimizations:
          1. Apply changes in order of priority
          2. Maintain code readability
          3. Preserve existing behavior
          4. Add comments explaining optimizations
        tool_budget: 35
        tools: [read, edit, write]
        llm_config:
          temperature: 0.1
        input_mapping:
          plan: optimization_plan
        output: optimization_result
        next: [verify_optimization]

      - id: verify_optimization
        type: compute
        name: "Verify Optimization"
        handler: test_runner
        inputs:
          test_command: $ctx.test_command
          timeout: 180
        output: test_results
        constraints:
          llm_allowed: false
          timeout: 180
        next: [check_tests]

      - id: check_tests
        type: condition
        name: "Check Tests"
        condition: "tests_passing"
        branches:
          "passing": complete
          "failing": fix_issues
          "no_tests": complete

      - id: fix_issues
        type: agent
        name: "Fix Issues"
        role: executor
        goal: |
          Fix any issues from optimization:
          1. Ensure behavior is preserved
          2. Fix any edge cases
        tool_budget: 20
        tools: [read, edit]
        llm_config:
          temperature: 0.2
        output: fix_result
        next: [verify_optimization]

      - id: complete
        type: transform
        name: "Complete"
        transform: |
          status = "completed"
          success = True
          optimizations_applied = ctx.get("optimization_plan", {}).get("optimizations", [])
